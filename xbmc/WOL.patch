
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -4445,7 +4445,51 @@ msgctxt "#13025"
 msgid "Joystick unplugged"
 msgstr ""
 
-#empty strings from id 13026 to 13049
+msgctxt "#13026"
+msgid "Try to wake remote servers on access"
+msgstr ""
+
+msgctxt "#13027"
+msgid "Wake on Lan (%s)"
+msgstr ""
+
+msgctxt "#13028"
+msgid "Waiting for network to connect..."
+msgstr ""
+
+msgctxt "#13029"
+msgid "Failed to execute Wake on Lan!"
+msgstr ""
+
+msgctxt "#13030"
+msgid "Waiting for server to wake up..."
+msgstr ""
+
+msgctxt "#13031"
+msgid "Extended wait for server to wake up..."
+msgstr ""
+
+msgctxt "#13032"
+msgid "Waiting for services to launch..."
+msgstr ""
+
+msgctxt "#13033"
+msgid "MAC Discovery"
+msgstr ""
+
+msgctxt "#13034"
+msgid "Updated for %s"
+msgstr ""
+
+msgctxt "#13035"
+msgid "Found for %s"
+msgstr ""
+
+msgctxt "#13036"
+msgid "Failed for %s"
+msgstr ""
+
+#empty strings from id 13037 to 13049
 
 msgctxt "#13050"
 msgid "Running low on battery"
diff --git a/project/VS2010Express/XBMC.vcxproj b/project/VS2010Express/XBMC.vcxproj
index 5ff57f8..628689f 100644
--- a/project/VS2010Express/XBMC.vcxproj
+++ b/project/VS2010Express/XBMC.vcxproj
@@ -843,6 +843,7 @@
     <ClCompile Include="..\..\xbmc\network\upnp\UPnPInternal.cpp" />
     <ClCompile Include="..\..\xbmc\network\upnp\UPnPRenderer.cpp" />
     <ClCompile Include="..\..\xbmc\network\upnp\UPnPServer.cpp" />
+    <ClCompile Include="..\..\xbmc\network\WakeOnAccess.cpp" />
     <ClCompile Include="..\..\xbmc\network\WebServer.cpp" />
     <ClCompile Include="..\..\xbmc\network\websocket\WebSocket.cpp" />
     <ClCompile Include="..\..\xbmc\network\websocket\WebSocketManager.cpp" />
@@ -1097,6 +1098,7 @@
     <ClInclude Include="..\..\xbmc\network\upnp\UPnPInternal.h" />
     <ClInclude Include="..\..\xbmc\network\upnp\UPnPRenderer.h" />
     <ClInclude Include="..\..\xbmc\network\upnp\UPnPServer.h" />
+    <ClInclude Include="..\..\xbmc\network\WakeOnAccess.h" />
     <ClInclude Include="..\..\xbmc\network\websocket\WebSocket.h" />
     <ClInclude Include="..\..\xbmc\network\websocket\WebSocketManager.h" />
     <ClInclude Include="..\..\xbmc\network\websocket\WebSocketV13.h" />
diff --git a/project/VS2010Express/XBMC.vcxproj.filters b/project/VS2010Express/XBMC.vcxproj.filters
index 53a6c97..16ee885 100644
--- a/project/VS2010Express/XBMC.vcxproj.filters
+++ b/project/VS2010Express/XBMC.vcxproj.filters
@@ -1345,6 +1345,9 @@
     <ClCompile Include="..\..\xbmc\network\UdpClient.cpp">
       <Filter>network</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\xbmc\network\WakeOnAccess.cpp">
+      <Filter>network</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\xbmc\network\WebServer.cpp">
       <Filter>network</Filter>
     </ClCompile>
@@ -4224,6 +4227,9 @@
     <ClInclude Include="..\..\xbmc\network\UdpClient.h">
       <Filter>network</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\xbmc\network\WakeOnAccess.h">
+      <Filter>network</Filter>
+    </ClInclude>
     <ClInclude Include="..\..\xbmc\network\WebServer.h">
       <Filter>network</Filter>
     </ClInclude>
diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index d5db046..9a49d2b 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -5086,17 +5086,23 @@ void CApplication::Process()
   // dispatch the messages generated by python or other threads to the current window
   g_windowManager.DispatchThreadMessages();
 
-  // process messages which have to be send to the gui
-  // (this can only be done after g_windowManager.Render())
-  CApplicationMessenger::Get().ProcessWindowMessages();
+  // only do full processing when m_slowTimer running
+  // if stopped, do a minimum and avoid anything causing file or db access
+  if (m_slowTimer.IsRunning())
+  {
+    // process messages which have to be send to the gui
+    // (this can only be done after g_windowManager.Render())
+    CApplicationMessenger::Get().ProcessWindowMessages();
 
 #ifdef HAS_PYTHON
-  // process any Python scripts
-  g_pythonParser.Process();
+    // process any Python scripts
+    g_pythonParser.Process();
 #endif
 
-  // process messages, even if a movie is playing
-  CApplicationMessenger::Get().ProcessMessages();
+    // process messages, even if a movie is playing
+    CApplicationMessenger::Get().ProcessMessages();
+  }
+
   if (g_application.m_bStop) return; //we're done, everything has been unloaded
 
   // check how far we are through playing the current item
@@ -5117,6 +5123,14 @@ void CApplication::Process()
   g_cpuInfo.getUsedPercentage(); // must call it to recalculate pct values
 }
 
+void CApplication::ProcessSlowEnable(bool enable)
+{
+  if (enable)
+    m_slowTimer.Start();
+  else
+    m_slowTimer.Stop();
+}
+
 // We get called every 500ms
 void CApplication::ProcessSlow()
 {
diff --git a/xbmc/Application.h b/xbmc/Application.h
index 69609fa..cbf5b27 100644
--- a/xbmc/Application.h
+++ b/xbmc/Application.h
@@ -207,6 +207,7 @@ class CApplication : public CXBApplicationEx, public IPlayerCallback, public IMs
 
   virtual void Process();
   void ProcessSlow();
+  void ProcessSlowEnable(bool enable);
   void ResetScreenSaver();
   int GetVolume() const;
   void SetVolume(float iValue, bool isPercentage = true);
diff --git a/xbmc/dbwrappers/mysqldataset.cpp b/xbmc/dbwrappers/mysqldataset.cpp
index ab92a80..e80b700 100644
--- a/xbmc/dbwrappers/mysqldataset.cpp
+++ b/xbmc/dbwrappers/mysqldataset.cpp
@@ -24,6 +24,7 @@
 
 #include "utils/log.h"
 #include "system.h" // for GetLastError()
+#include "network/WakeOnAccess.h"
 
 #ifdef HAS_MYSQL
 #include "mysqldataset.h"
@@ -119,6 +120,8 @@ int MysqlDatabase::connect(bool create_new) {
     if (conn == NULL)
       conn = mysql_init(conn);
 
+    CWakeOnAccess::Get().WakeUpHost(host, "MySQL : " + db);
+
     // establish connection with just user credentials
     if (mysql_real_connect(conn, host.c_str(),login.c_str(),passwd.c_str(), NULL, atoi(port.c_str()),NULL,0) != NULL)
     {
diff --git a/xbmc/filesystem/DirectoryFactory.cpp b/xbmc/filesystem/DirectoryFactory.cpp
index 9fb2169..1fe45bf 100644
--- a/xbmc/filesystem/DirectoryFactory.cpp
+++ b/xbmc/filesystem/DirectoryFactory.cpp
@@ -44,6 +44,7 @@
 #include "Application.h"
 #include "addons/Addon.h"
 #include "utils/log.h"
+#include "network/WakeOnAccess.h"
 
 #ifdef HAS_FILESYSTEM_SMB
 #ifdef _WIN32
@@ -124,6 +125,7 @@
 IDirectory* CDirectoryFactory::Create(const CStdString& strPath)
 {
   CURL url(strPath);
+  CWakeOnAccess::Get().WakeUpHost(url);
 
   CFileItem item(strPath, false);
   IFileDirectory* pDir=CFileDirectoryFactory::Create(strPath, &item);
diff --git a/xbmc/filesystem/FileFactory.cpp b/xbmc/filesystem/FileFactory.cpp
index a042d39..0c8f986 100644
--- a/xbmc/filesystem/FileFactory.cpp
+++ b/xbmc/filesystem/FileFactory.cpp
@@ -95,6 +95,7 @@
 #include "Application.h"
 #include "URL.h"
 #include "utils/log.h"
+#include "network/WakeOnAccess.h"
 
 using namespace XFILE;
 
@@ -114,6 +115,8 @@ IFile* CFileFactory::CreateLoader(const CStdString& strFileName)
 
 IFile* CFileFactory::CreateLoader(const CURL& url)
 {
+  CWakeOnAccess::Get().WakeUpHost(url);
+
   CStdString strProtocol = url.GetProtocol();
   strProtocol.MakeLower();
 
diff --git a/xbmc/main/main.cpp b/xbmc/main/main.cpp
index 8fe4226..81181a0 100644
--- a/xbmc/main/main.cpp
+++ b/xbmc/main/main.cpp
@@ -66,13 +66,6 @@ int main(int argc, char* argv[])
   if (setrlimit(RLIMIT_CORE, &rlim) == -1)
     CLog::Log(LOGDEBUG, "Failed to set core size limit (%s)", strerror(errno));
 #endif
-  // Prevent child processes from becoming zombies on exit if not waited upon. See also Util::Command
-  struct sigaction sa;
-  memset(&sa, 0, sizeof(sa));
-
-  sa.sa_flags = SA_NOCLDWAIT;
-  sa.sa_handler = SIG_IGN;
-  sigaction(SIGCHLD, &sa, NULL);
 #endif
   setlocale(LC_NUMERIC, "C");
   g_advancedSettings.Initialize();
diff --git a/xbmc/network/Makefile.in b/xbmc/network/Makefile.in
index e2ffb0b..4e680fc 100644
--- a/xbmc/network/Makefile.in
+++ b/xbmc/network/Makefile.in
@@ -9,6 +9,7 @@ SRCS += Network.cpp
 SRCS += Socket.cpp
 SRCS += TCPServer.cpp
 SRCS += UdpClient.cpp
+SRCS += WakeOnAccess.cpp
 SRCS += WebServer.cpp
 SRCS += ZeroconfBrowser.cpp
 SRCS += Zeroconf.cpp
diff --git a/xbmc/network/Network.h b/xbmc/network/Network.h
index 1aaa764..8d46a6e 100644
--- a/xbmc/network/Network.h
+++ b/xbmc/network/Network.h
@@ -62,6 +62,8 @@ class CNetworkInterface
    virtual CStdString GetMacAddress(void) = 0;
    virtual void GetMacAddressRaw(char rawMac[6]) = 0;
 
+   virtual bool GetHostMacAddress(unsigned long host, CStdString& mac) = 0;
+
    virtual CStdString GetCurrentIPAddress() = 0;
    virtual CStdString GetCurrentNetmask() = 0;
    virtual CStdString GetCurrentDefaultGateway(void) = 0;
@@ -110,6 +112,9 @@ class CNetwork
    // Return true if the magic packet was send
    bool WakeOnLan(const char *mac);
 
+   // Return true if host replies to ping
+   virtual bool PingHost(unsigned long host, unsigned int timeout_ms = 2000) = 0;
+
    // Get/set the nameserver(s)
    virtual std::vector<CStdString> GetNameServers(void) = 0;
    virtual void SetNameServers(std::vector<CStdString> nameServers) = 0;
diff --git a/xbmc/network/WakeOnAccess.cpp b/xbmc/network/WakeOnAccess.cpp
new file mode 100644
index 0000000..49f78cb
--- /dev/null
+++ b/xbmc/network/WakeOnAccess.cpp
@@ -0,0 +1,659 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <limits.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include "system.h"
+#include "network/Network.h"
+#include "Application.h"
+#include "DNSNameCache.h"
+#include "dialogs/GUIDialogProgress.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "filesystem/SpecialProtocol.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/LocalizeStrings.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+#include "utils/JobManager.h"
+#include "utils/log.h"
+#include "utils/XMLUtils.h"
+
+#include "WakeOnAccess.h"
+
+using namespace std;
+
+#define DEFAULT_NETWORK_INIT_SEC      (20)   // wait 20 sec for network after startup or resume
+#define DEFAULT_NETWORK_SETTLE_MS     (500)  // require 500ms of consistent network availability before trusting it
+
+#define DEFAULT_TIMEOUT_SEC (5*60)           // at least 5 minutes between each magic packets
+#define DEFAULT_WAIT_FOR_ONLINE_SEC_1 (40)   // wait at 40 seconds after sending magic packet
+#define DEFAULT_WAIT_FOR_ONLINE_SEC_2 (40)   // same for extended wait
+#define DEFAULT_WAIT_FOR_SERVICES_SEC (5)    // wait 5 seconds after host go online to launch file sharing deamons
+
+static int GetTotalSeconds(const CDateTimeSpan& ts)
+{
+  int hours = ts.GetHours() + ts.GetDays() * 24;
+  int minutes = ts.GetMinutes() + hours * 60;
+  return ts.GetSeconds() + minutes * 60;
+}
+
+static unsigned long HostToIP(const CStdString& host)
+{
+  CStdString ip;
+  CDNSNameCache::Lookup(host, ip);
+  return inet_addr(ip.c_str());
+}
+
+CWakeOnAccess::WakeUpEntry::WakeUpEntry (bool isAwake)
+  : timeout (0, 0, 0, DEFAULT_TIMEOUT_SEC)
+  , wait_online1_sec(DEFAULT_WAIT_FOR_ONLINE_SEC_1)
+  , wait_online2_sec(DEFAULT_WAIT_FOR_ONLINE_SEC_2)
+  , wait_services_sec(DEFAULT_WAIT_FOR_SERVICES_SEC)
+{
+  nextWake = CDateTime::GetCurrentDateTime();
+
+  if (isAwake)
+    nextWake += timeout;
+}
+
+CWakeOnAccess::CMACDiscoveryJob::CMACDiscoveryJob(const CStdString& host)
+  : m_host(host)
+{
+}
+
+bool CWakeOnAccess::CMACDiscoveryJob::DoWork()
+{
+  unsigned long ipAddress = HostToIP(m_host);
+
+  if (ipAddress == INADDR_NONE)
+  {
+    CLog::Log(LOGERROR, "%s - can't determine ip of '%s'", __FUNCTION__, m_host.c_str());
+    return false;
+  }
+
+  vector<CNetworkInterface*>& ifaces = g_application.getNetwork().GetInterfaceList();
+  for (vector<CNetworkInterface*>::const_iterator it = ifaces.begin(); it != ifaces.end(); ++it)
+  {
+    if ((*it)->GetHostMacAddress(ipAddress, m_macAddres))
+      return true;
+  }
+
+  return false;
+}
+
+const CStdString& CWakeOnAccess::CMACDiscoveryJob::GetMAC() const
+{
+  return m_macAddres;
+}
+
+const CStdString& CWakeOnAccess::CMACDiscoveryJob::GetHost() const
+{
+  return m_host;
+}
+
+class WaitCondition
+{
+public:
+  virtual bool SuccessWaiting () const { return false; }
+};
+
+class ProgressDialogHelper
+{
+public:
+  ProgressDialogHelper (const CStdString& heading) : m_dialog(0)
+  {
+    if (g_application.IsCurrentThread() && !g_application.IsPlaying())
+      m_dialog = (CGUIDialogProgress*) g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS);
+
+    if (m_dialog)
+    {
+      m_dialog->SetHeading (heading); 
+      m_dialog->SetLine(0, "");
+      m_dialog->SetLine(1, "");
+      m_dialog->SetLine(2, "");
+      g_application.ProcessSlowEnable(false); // ProcessSlow will normally be done while dialog->Progress and may call back recursively to wake sleeping server !
+    }
+  }
+  ~ProgressDialogHelper ()
+  {
+    if (m_dialog)
+    {
+      m_dialog->Close();
+      g_application.ProcessSlowEnable(true);
+    }
+  }
+
+  enum wait_result { TimedOut, Canceled, Success };
+
+  wait_result ShowAndWait (const WaitCondition& waitObj, unsigned timeOutSec, const CStdString& line1)
+  {
+    unsigned timeOutMs = timeOutSec * 1000;
+
+    if (m_dialog)
+    {
+      m_dialog->SetLine(1, line1);
+
+      m_dialog->SetPercentage(1); // avoid flickering by starting at 1% ..
+    }
+
+    XbmcThreads::EndTime end_time (timeOutMs);
+
+    while (!end_time.IsTimePast())
+    {
+      if (waitObj.SuccessWaiting())
+        return Success;
+            
+      if (m_dialog)
+      {
+        if (!m_dialog->IsActive())
+          m_dialog->StartModal();
+
+        if (m_dialog->IsCanceled())
+          return Canceled;
+
+        m_dialog->Progress();
+
+        unsigned ms_passed = timeOutMs - end_time.MillisLeft();
+
+        int percentage = (ms_passed * 100) / timeOutMs;
+        m_dialog->SetPercentage(max(percentage, 1)); // avoid flickering , keep minimum 1%
+      }
+
+      Sleep (m_dialog ? 20 : 200);
+    }
+
+    return TimedOut;
+  }
+
+private:
+  CGUIDialogProgress* m_dialog;
+};
+
+class NetworkStartWaiter : public WaitCondition
+{
+public:
+  NetworkStartWaiter (unsigned settle_time_ms) : m_settle_time_ms (settle_time_ms)
+  {
+  }
+  virtual bool SuccessWaiting () const
+  {
+    CNetworkInterface* iface = g_application.getNetwork().GetFirstConnectedInterface();
+
+    bool online = iface && iface->IsEnabled();
+
+    if (!online) // setup endtime so we dont return true until network is consistently connected
+      m_end.Set (m_settle_time_ms);
+
+    return online && m_end.IsTimePast();
+  }
+private:
+  mutable XbmcThreads::EndTime m_end;
+  unsigned m_settle_time_ms;
+};
+
+class PingResponseWaiter : public WaitCondition, private IJobCallback
+{
+public:
+  PingResponseWaiter (const CStdString& host) : m_hostOnline (false)
+  {
+    m_job = new CHostProberJob(host);
+    CSingleLock lock(m_section);
+    m_jobId = CJobManager::GetInstance().AddJob(m_job, this);
+  }
+  ~PingResponseWaiter()
+  {
+    CSingleLock lock(m_section);
+    if (m_job)
+      CJobManager::GetInstance().CancelJob(m_jobId);
+  }
+  virtual bool SuccessWaiting () const
+  {
+    return m_hostOnline;
+  }
+
+  virtual void OnJobComplete(unsigned int jobID, bool success, CJob *job)
+  {
+    m_hostOnline = success;
+    CSingleLock lock(m_section);
+    m_job = 0;
+  }
+
+private:
+  class CHostProberJob : public CJob
+  {
+    public:
+      CHostProberJob(const CStdString& host) : m_host (host) {}
+
+      virtual bool DoWork()
+      {
+        while (!ShouldCancel(0,0))
+        {
+          ULONG dst_ip = HostToIP(m_host);
+
+          if (g_application.getNetwork().PingHost(dst_ip, 2000))
+            return true;
+        }
+        return false;
+      }
+
+    private:
+      CStdString m_host;
+  };
+
+  bool m_hostOnline;
+  CHostProberJob* m_job;
+  unsigned int m_jobId;
+  CCriticalSection m_section;
+};
+
+//
+
+class NestDetect
+{
+public:
+  NestDetect() : m_gui_thread (g_application.IsCurrentThread())
+  {
+    if (m_gui_thread)
+      ++m_nest;
+  }
+  ~NestDetect()
+  {
+    if (m_gui_thread)
+      m_nest--;
+  }
+  bool TooDeep() const
+  {
+    return m_gui_thread && m_nest > 1;
+  }
+
+private:
+  static int m_nest;
+  const bool m_gui_thread;
+};
+int NestDetect::m_nest = 0;
+
+//
+
+CWakeOnAccess::CWakeOnAccess()
+  : m_netinit_sec(DEFAULT_NETWORK_INIT_SEC)    // wait for network to connect
+  , m_netsettle_ms(DEFAULT_NETWORK_SETTLE_MS)  // wait for network to settle
+  , m_enabled(false)
+{
+}
+
+CWakeOnAccess &CWakeOnAccess::Get()
+{
+  static CWakeOnAccess sWakeOnAccess;
+  return sWakeOnAccess;
+}
+
+void CWakeOnAccess::WakeUpHost(const CURL& url)
+{
+  CStdString hostName = url.GetHostName();
+
+  if (!hostName.IsEmpty())
+    WakeUpHost (hostName, url.Get());
+}
+
+void CWakeOnAccess::WakeUpHost (const CStdString& hostName, const string& customMessage)
+{
+  if (!IsEnabled())
+    return; // bail if feature is turned off
+
+  for (EntriesVector::iterator i = m_entries.begin();i != m_entries.end(); ++i)
+  {
+    WakeUpEntry& server = *i;
+
+    if (hostName.Equals(server.host.c_str()))
+    {
+      CDateTime now = CDateTime::GetCurrentDateTime();
+
+      if (now > server.nextWake)
+      {
+        CLog::Log(LOGNOTICE,"WakeOnAccess [%s] trigged by accessing : %s", hostName.c_str(), customMessage.c_str());
+
+        NestDetect nesting ; // detect recursive calls on gui thread and bail out
+
+        if (nesting.TooDeep()) // we can not maintain progress-dialog if it gets called back in loop
+        {
+          CLog::Log(LOGERROR,"WakeOnAccess recursively called on gui-thread : aborting ");
+          return;
+        }
+
+        WakeUpHost(server);
+      }
+
+      server.nextWake = now + server.timeout;
+
+      return;
+    }
+  }
+}
+
+#define LOCALIZED(id) g_localizeStrings.Get(id)
+
+void CWakeOnAccess::WakeUpHost(const WakeUpEntry& server)
+{
+  CStdString heading = LOCALIZED(13027);
+  heading.Format (heading, server.host);
+
+  ProgressDialogHelper dlg (heading);
+
+  {
+    NetworkStartWaiter waitObj (m_netsettle_ms); // wait until network connected before sending wake-on-lan
+
+    if (dlg.ShowAndWait (waitObj, m_netinit_sec, LOCALIZED(13028)) != ProgressDialogHelper::Success)
+    {
+      CLog::Log(LOGNOTICE,"WakeOnAccess timeout/cancel while waiting for network");
+      return; // timedout or canceled
+    }
+  }
+
+  {
+    ULONG dst_ip = HostToIP(server.host);
+
+    if (g_application.getNetwork().PingHost(dst_ip, 500)) // quick ping with short timeout to not block too long
+    {
+      CLog::Log(LOGNOTICE,"WakeOnAccess success exit, server already running");
+      return;
+    }
+  }
+
+  if (!g_application.getNetwork().WakeOnLan(server.mac.c_str()))
+  {
+    CLog::Log(LOGERROR,"WakeOnAccess failed to send. (Is it blocked by firewall?)");
+
+    if (!g_application.IsPlaying())
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, heading, LOCALIZED(13029));
+    return;
+  }
+
+  {
+    PingResponseWaiter waitObj (server.host); // wait for ping response ..
+
+    ProgressDialogHelper::wait_result 
+      result = dlg.ShowAndWait (waitObj, server.wait_online1_sec, LOCALIZED(13030));
+
+    if (result == ProgressDialogHelper::TimedOut)
+      result = dlg.ShowAndWait (waitObj, server.wait_online2_sec, LOCALIZED(13031));
+
+    if (result != ProgressDialogHelper::Success)
+    {
+      CLog::Log(LOGNOTICE,"WakeOnAccess timeout/cancel while waiting for response");
+      return; // timedout or canceled
+    }
+  }
+
+  {
+    WaitCondition waitObj ; // wait uninteruptable fixed time for services ..
+
+    dlg.ShowAndWait (waitObj, server.wait_services_sec, LOCALIZED(13032));
+
+    CLog::Log(LOGNOTICE,"WakeOnAccess sequence completed, server started");
+  }
+}
+
+static void AddHost (const CStdString& host, vector<string>& hosts)
+{
+  for (vector<string>::const_iterator it = hosts.begin(); it != hosts.end(); ++it)
+    if (host.Equals((*it).c_str()))
+      return; // allready there ..
+
+  if (!host.IsEmpty())
+    hosts.push_back(host);
+}
+
+static void AddHostFromDatabase(const DatabaseSettings& setting, vector<string>& hosts)
+{
+  if (setting.type.Equals("mysql"))
+    AddHost(setting.host, hosts);
+}
+
+void CWakeOnAccess::QueueMACDiscoveryForHost(const CStdString& host)
+{
+  if (IsEnabled())
+    CJobManager::GetInstance().AddJob(new CMACDiscoveryJob(host), this);
+}
+
+void CWakeOnAccess::AddHostsFromShare(const CMediaSource& source, std::vector<std::string>& hosts)
+{
+  for (CStdStringArray::const_iterator it = source.vecPaths.begin() ; it != source.vecPaths.end(); it++)
+  {
+    CURL url = *it;
+
+    AddHost (url.GetHostName(), hosts);
+  }
+}
+
+void CWakeOnAccess::AddHostsFromShares(const VECSOURCES& sources, vector<string>& hosts)
+{
+  for (VECSOURCES::const_iterator it = sources.begin(); it != sources.end(); it++)
+    AddHostsFromShare(*it, hosts);
+}
+
+void CWakeOnAccess::QueueMACDiscoveryForShare(const CMediaSource& source)
+{
+  vector<string> hosts;
+  AddHostsFromShare(source, hosts);
+  for (vector<string>::const_iterator it = hosts.begin(); it != hosts.end(); it++)
+    QueueMACDiscoveryForHost(*it);
+}
+
+void CWakeOnAccess::QueueMACDiscoveryForAllRemotes()
+{
+  vector<string> hosts;
+
+  // add media sources
+  AddHostsFromShares(g_settings.m_videoSources, hosts);
+  AddHostsFromShares(g_settings.m_musicSources, hosts);
+  AddHostsFromShares(g_settings.m_pictureSources, hosts);
+  AddHostsFromShares(g_settings.m_fileSources, hosts);
+
+  // add mysql servers
+  AddHostFromDatabase(g_advancedSettings.m_databaseVideo, hosts);
+  AddHostFromDatabase(g_advancedSettings.m_databaseMusic, hosts);
+  AddHostFromDatabase(g_advancedSettings.m_databaseEpg, hosts);
+  AddHostFromDatabase(g_advancedSettings.m_databaseTV, hosts);
+
+  // add from path substitutions ..
+  for (CAdvancedSettings::StringMapping::iterator i = g_advancedSettings.m_pathSubstitutions.begin(); i != g_advancedSettings.m_pathSubstitutions.end(); ++i)
+  {
+    CURL url = i->second;
+
+    AddHost (url.GetHostName(), hosts);
+  }
+
+  for (vector<string>::const_iterator it = hosts.begin(); it != hosts.end(); it++)
+    QueueMACDiscoveryForHost(*it);
+}
+
+void CWakeOnAccess::OnJobComplete(unsigned int jobID, bool success, CJob *job)
+{
+  CMACDiscoveryJob* discoverJob = (CMACDiscoveryJob*)job;
+
+  CStdString heading = LOCALIZED(13033);
+
+  if (success)
+  {
+    CLog::Log(LOGNOTICE, "%s - Mac discovered for host '%s' -> '%s'", __FUNCTION__, discoverJob->GetHost().c_str(), discoverJob->GetMAC().c_str());
+    for (EntriesVector::iterator i = m_entries.begin(); i != m_entries.end(); ++i)
+    {
+      if (discoverJob->GetHost().Equals(i->host.c_str()))
+      {
+        CLog::Log(LOGDEBUG, "%s - Update existing entry for host '%s'", __FUNCTION__, discoverJob->GetHost().c_str());
+        if (!discoverJob->GetMAC().Equals(i->mac.c_str()))
+        {
+          if (IsEnabled()) // show notification only if we have general feature enabled
+          {
+            CStdString message = LOCALIZED(13034);
+            message.Format(message, discoverJob->GetHost());
+            CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, heading, message, 4000, true, 3000);
+          }
+
+          i->mac = discoverJob->GetMAC();
+          SaveToXML();
+        }
+
+        return;
+      }
+    }
+
+    // not found entry to update - create using default values
+    WakeUpEntry entry (true);
+    entry.host = discoverJob->GetHost();
+    entry.mac  = discoverJob->GetMAC();
+    m_entries.push_back(entry);
+
+    CLog::Log(LOGDEBUG, "%s - Create new entry for host '%s'", __FUNCTION__, discoverJob->GetHost().c_str());
+    if (IsEnabled()) // show notification only if we have general feature enabled
+    {
+      CStdString message = LOCALIZED(13035);
+      message.Format(message, discoverJob->GetHost());
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, heading, message, 4000, true, 3000);
+    }
+
+    SaveToXML();
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "%s - Mac discovery failed for host '%s'", __FUNCTION__, discoverJob->GetHost().c_str());
+
+    if (IsEnabled())
+    {
+      CStdString message = LOCALIZED(13036);
+      message.Format(message, discoverJob->GetHost());
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, heading, message, 4000, true, 3000);
+    }
+  }
+}
+
+CStdString CWakeOnAccess::GetSettingFile()
+{
+  return CSpecialProtocol::TranslatePath("special://masterprofile/wakeonlan.xml");
+}
+
+void CWakeOnAccess::LoadFromXML()
+{
+  SetEnabled(g_guiSettings.GetBool("powermanagement.wakeonaccess"));
+
+  CXBMCTinyXML xmlDoc;
+  if (!xmlDoc.LoadFile(GetSettingFile()))
+  {
+    CLog::Log(LOGNOTICE, "%s - unable to load:%s", __FUNCTION__, GetSettingFile().c_str());
+    return;
+  }
+
+  TiXmlElement* pRootElement = xmlDoc.RootElement();
+  if (strcmpi(pRootElement->Value(), "onaccesswakeup"))
+  {
+    CLog::Log(LOGERROR, "%s - XML file %s doesnt contain <onaccesswakeup>", __FUNCTION__, GetSettingFile().c_str());
+    return;
+  }
+
+  m_entries.clear();
+
+  CLog::Log(LOGNOTICE,"WakeOnAccess - Load settings :");
+
+  int tmp;
+  if (XMLUtils::GetInt(pRootElement, "netinittimeout", tmp, 0, 5 * 60))
+    m_netinit_sec = tmp;
+  CLog::Log(LOGNOTICE,"  -Network init timeout : [%d] sec", m_netinit_sec);
+  
+  if (XMLUtils::GetInt(pRootElement, "netsettletime", tmp, 0, 5 * 1000))
+    m_netsettle_ms = tmp;
+  CLog::Log(LOGNOTICE,"  -Network settle time  : [%d] ms", m_netsettle_ms);
+
+  const TiXmlNode* pWakeUp = pRootElement->FirstChildElement("wakeup");
+  while (pWakeUp)
+  {
+    WakeUpEntry entry;
+
+    CStdString strtmp;
+    if (XMLUtils::GetString(pWakeUp, "host", strtmp))
+      entry.host = strtmp;
+
+    if (XMLUtils::GetString(pWakeUp, "mac", strtmp))
+      entry.mac = strtmp;
+
+    if (entry.host.empty())
+      CLog::Log(LOGERROR, "%s - Missing <host> tag or it's empty", __FUNCTION__);
+    else if (entry.mac.empty())
+       CLog::Log(LOGERROR, "%s - Missing <mac> tag or it's empty", __FUNCTION__);
+    else
+    {
+      if (XMLUtils::GetInt(pWakeUp, "timeout", tmp, 10, 12 * 60 * 60))
+        entry.timeout.SetDateTimeSpan (0, 0, 0, tmp);
+
+      if (XMLUtils::GetInt(pWakeUp, "waitonline", tmp, 0, 10 * 60)) // max 10 minutes
+        entry.wait_online1_sec = tmp;
+
+      if (XMLUtils::GetInt(pWakeUp, "waitonline2", tmp, 0, 10 * 60)) // max 10 minutes
+        entry.wait_online2_sec = tmp;
+
+      if (XMLUtils::GetInt(pWakeUp, "waitservices", tmp, 0, 5 * 60)) // max 5 minutes
+        entry.wait_services_sec = tmp;
+
+      CLog::Log(LOGNOTICE,"  Registering wakeup entry:");
+      CLog::Log(LOGNOTICE,"    HostName        : %s", entry.host.c_str());
+      CLog::Log(LOGNOTICE,"    MacAddress      : %s", entry.mac.c_str());
+      CLog::Log(LOGNOTICE,"    Timeout         : %d (sec)", GetTotalSeconds(entry.timeout));
+      CLog::Log(LOGNOTICE,"    WaitForOnline   : %d (sec)", entry.wait_online1_sec);
+      CLog::Log(LOGNOTICE,"    WaitForOnlineEx : %d (sec)", entry.wait_online2_sec);
+      CLog::Log(LOGNOTICE,"    WaitForServices : %d (sec)", entry.wait_services_sec);
+
+      m_entries.push_back(entry);
+    }
+
+    pWakeUp = pWakeUp->NextSiblingElement("wakeup"); // get next one
+  }
+}
+
+void CWakeOnAccess::SaveToXML()
+{
+  CXBMCTinyXML xmlDoc;
+  TiXmlElement xmlRootElement("onaccesswakeup");
+  TiXmlNode *pRoot = xmlDoc.InsertEndChild(xmlRootElement);
+  if (!pRoot) return;
+
+  XMLUtils::SetInt(pRoot, "netinittimeout", m_netinit_sec);
+  XMLUtils::SetInt(pRoot, "netsettletime", m_netsettle_ms);
+
+  for (EntriesVector::const_iterator i = m_entries.begin(); i != m_entries.end(); ++i)
+  {
+    TiXmlElement xmlSetting("wakeup");
+    TiXmlNode* pWakeUpNode = pRoot->InsertEndChild(xmlSetting);
+    if (pWakeUpNode)
+    {
+      XMLUtils::SetString(pWakeUpNode, "host", i->host);
+      XMLUtils::SetString(pWakeUpNode, "mac", i->mac);
+      XMLUtils::SetInt(pWakeUpNode, "timeout", GetTotalSeconds(i->timeout));
+      XMLUtils::SetInt(pWakeUpNode, "waitonline", i->wait_online1_sec);
+      XMLUtils::SetInt(pWakeUpNode, "waitonline2", i->wait_online2_sec);
+      XMLUtils::SetInt(pWakeUpNode, "waitservices", i->wait_services_sec);
+    }
+  }
+
+  xmlDoc.SaveFile(GetSettingFile());
+}
diff --git a/xbmc/network/WakeOnAccess.h b/xbmc/network/WakeOnAccess.h
new file mode 100644
index 0000000..ee3bd9e
--- /dev/null
+++ b/xbmc/network/WakeOnAccess.h
@@ -0,0 +1,90 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "URL.h"
+#include "MediaSource.h"
+#include "XBDateTime.h"
+#include "utils/Job.h"
+
+class CWakeOnAccess : public IJobCallback
+{
+public:
+  CWakeOnAccess();
+  static CWakeOnAccess &Get();
+
+  void WakeUpHost (const CURL& fileUrl);
+  void WakeUpHost (const CStdString& hostName, const std::string& customMessage);
+
+  void SetEnabled(bool enabled) { m_enabled = enabled; }
+  bool IsEnabled() const { return m_enabled; }
+
+  void QueueMACDiscoveryForHost(const CStdString& host);
+  void QueueMACDiscoveryForShare(const CMediaSource& source);
+  void QueueMACDiscoveryForAllRemotes();
+
+  virtual void OnJobComplete(unsigned int jobID, bool success, CJob *job);
+
+  void LoadFromXML();
+private:
+  void AddHostsFromShare(const CMediaSource& source, std::vector<std::string>& hosts);
+  void AddHostsFromShares(const VECSOURCES& sources, std::vector<std::string>& hosts);
+
+  CStdString GetSettingFile();
+  void SaveToXML();
+
+  class CMACDiscoveryJob : public CJob
+  {
+  public:
+    CMACDiscoveryJob(const CStdString& host);
+
+    virtual bool DoWork();
+
+    const CStdString& GetMAC() const;
+    const CStdString& GetHost() const;
+  private:
+    CStdString m_macAddres;
+    CStdString m_host;
+  };
+  
+  // struct to keep per host settings
+  struct WakeUpEntry
+  {
+    WakeUpEntry (bool isAwake = false);
+
+    std::string host;
+    std::string mac;
+    CDateTimeSpan timeout;
+    unsigned int wait_online1_sec; // initial wait
+    unsigned int wait_online2_sec; // extended wait
+    unsigned int wait_services_sec;
+
+    CDateTime nextWake;
+  };
+
+  typedef std::vector<WakeUpEntry> EntriesVector;
+  EntriesVector m_entries;
+
+  unsigned int m_netinit_sec, m_netsettle_ms; //time to wait for network connection
+
+  bool m_enabled;
+
+  void WakeUpHost(const WakeUpEntry& server);
+};
diff --git a/xbmc/network/linux/NetworkLinux.cpp b/xbmc/network/linux/NetworkLinux.cpp
index 582d3e3..411f60c 100644
--- a/xbmc/network/linux/NetworkLinux.cpp
+++ b/xbmc/network/linux/NetworkLinux.cpp
@@ -520,6 +520,63 @@ void CNetworkLinux::SetNameServers(std::vector<CStdString> nameServers)
 #endif
 }
 
+bool CNetworkLinux::PingHost(unsigned long remote_ip, unsigned int timeout_ms)
+{
+  char cmd_line [64];
+
+  struct in_addr host_ip; 
+  host_ip.s_addr = remote_ip;
+
+  sprintf(cmd_line, "ping -c 1 -w %d %s", timeout_ms / 1000 + (timeout_ms % 1000) != 0, inet_ntoa(host_ip));
+
+  int status = system (cmd_line);
+
+  int result = WIFEXITED(status) ? WEXITSTATUS(status) : -1;
+
+  // http://linux.about.com/od/commands/l/blcmdl8_ping.htm ;
+  // 0 reply
+  // 1 no reply
+  // else some error
+
+  if (result < 0 || result > 1)
+    CLog::Log(LOGERROR, "Ping fail : status = %d, errno = %d : '%s'", status, errno, cmd_line);
+
+  return result == 0;
+}
+
+bool CNetworkInterfaceLinux::GetHostMacAddress(unsigned long host_ip, CStdString& mac)
+{
+  struct arpreq areq;
+  struct sockaddr_in* sin;
+
+  memset(&areq, 0x0, sizeof(areq));
+
+  sin = (struct sockaddr_in *) &areq.arp_pa;
+  sin->sin_family = AF_INET;
+  sin->sin_addr.s_addr = host_ip;
+
+  sin = (struct sockaddr_in *) &areq.arp_ha;
+  sin->sin_family = ARPHRD_ETHER;
+
+  strncpy(areq.arp_dev, m_interfaceName.c_str(), sizeof(areq.arp_dev));
+  areq.arp_dev[sizeof(areq.arp_dev)-1] = '\0';
+
+  int result = ioctl (m_network->GetSocket(), SIOCGARP, (caddr_t) &areq);
+
+  if (result != 0)
+  {
+//  CLog::Log(LOGERROR, "%s - GetHostMacAddress/ioctl failed with errno (%d)", __FUNCTION__, errno);
+    return false;
+  }
+
+  struct sockaddr* res = &areq.arp_ha;
+  mac.Format("%02X:%02X:%02X:%02X:%02X:%02X", 
+    (uint8_t) res->sa_data[0], (uint8_t) res->sa_data[1], (uint8_t) res->sa_data[2], 
+    (uint8_t) res->sa_data[3], (uint8_t) res->sa_data[4], (uint8_t) res->sa_data[5]);
+
+  return true;
+}
+
 std::vector<NetworkAccessPoint> CNetworkInterfaceLinux::GetAccessPoints(void)
 {
    std::vector<NetworkAccessPoint> result;
diff --git a/xbmc/network/linux/NetworkLinux.h b/xbmc/network/linux/NetworkLinux.h
index df09498..c941d25 100644
--- a/xbmc/network/linux/NetworkLinux.h
+++ b/xbmc/network/linux/NetworkLinux.h
@@ -42,6 +42,8 @@ class CNetworkInterfaceLinux : public CNetworkInterface
    virtual CStdString GetMacAddress(void);
    virtual void GetMacAddressRaw(char rawMac[6]);
 
+   virtual bool GetHostMacAddress(unsigned long host, CStdString& mac);
+
    virtual CStdString GetCurrentIPAddress();
    virtual CStdString GetCurrentNetmask();
    virtual CStdString GetCurrentDefaultGateway(void);
@@ -71,6 +73,9 @@ class CNetworkLinux : public CNetwork
    virtual std::vector<CNetworkInterface*>& GetInterfaceList(void);
    virtual CNetworkInterface* GetFirstConnectedInterface(void);        
     
+   // Ping remote host
+   virtual bool PingHost(unsigned long host, unsigned int timeout_ms = 2000);
+
    // Get/set the nameserver(s)
    virtual std::vector<CStdString> GetNameServers(void);
    virtual void SetNameServers(std::vector<CStdString> nameServers);
diff --git a/xbmc/network/windows/NetworkWin32.cpp b/xbmc/network/windows/NetworkWin32.cpp
index 04b9917..4b4eeb0 100644
--- a/xbmc/network/windows/NetworkWin32.cpp
+++ b/xbmc/network/windows/NetworkWin32.cpp
@@ -19,6 +19,8 @@
  */
 
 #include <errno.h>
+#include <iphlpapi.h>
+#include <IcmpAPI.h>
 #include "PlatformDefs.h"
 #include "NetworkWin32.h"
 #include "utils/log.h"
@@ -261,6 +263,58 @@ void CNetworkWin32::SetNameServers(std::vector<CStdString> nameServers)
   return;
 }
 
+bool CNetworkWin32::PingHost(unsigned long host, unsigned int timeout_ms /* = 2000 */)
+{
+  char SendData[]    = "poke";
+  HANDLE hIcmpFile   = IcmpCreateFile();
+  BYTE ReplyBuffer [sizeof(ICMP_ECHO_REPLY) + sizeof(SendData)];
+
+  SetLastError(ERROR_SUCCESS);
+
+  DWORD dwRetVal = IcmpSendEcho(hIcmpFile, host, SendData, sizeof(SendData), 
+                                NULL, ReplyBuffer, sizeof(ReplyBuffer), timeout_ms);
+
+  DWORD lastErr = GetLastError();
+  if (lastErr != ERROR_SUCCESS)
+    CLog::Log(LOGERROR, "%s - IcmpSendEcho failed (%d)", __FUNCTION__, lastErr);
+
+  IcmpCloseHandle (hIcmpFile);
+
+  if (dwRetVal != 0)
+  {
+    PICMP_ECHO_REPLY pEchoReply = (PICMP_ECHO_REPLY)ReplyBuffer;
+    return (pEchoReply->Status == IP_SUCCESS);
+  }
+  return false;
+}
+
+bool CNetworkInterfaceWin32::GetHostMacAddress(unsigned long host, CStdString& mac)
+{
+  IPAddr src_ip = inet_addr(GetCurrentIPAddress().c_str());
+  BYTE bPhysAddr[6];      // for 6-byte hardware addresses
+  ULONG PhysAddrLen = 6;  // default to length of six bytes
+
+  memset(&bPhysAddr, 0xff, sizeof (bPhysAddr));
+
+  DWORD dwRetVal = SendARP(host, src_ip, &bPhysAddr, &PhysAddrLen);
+  if (dwRetVal == NO_ERROR)
+  {
+    if (PhysAddrLen == 6)
+    {
+      mac.Format("%02X:%02X:%02X:%02X:%02X:%02X", 
+        bPhysAddr[0], bPhysAddr[1], bPhysAddr[2], 
+        bPhysAddr[3], bPhysAddr[4], bPhysAddr[5]);
+      return true;
+    }
+    else
+      CLog::Log(LOGERROR, "%s - SendArp completed successfully, but mac address has length != 6 (%d)", __FUNCTION__, PhysAddrLen);
+  }
+  else
+    CLog::Log(LOGERROR, "%s - SendArp failed with error (%d)", __FUNCTION__, dwRetVal);
+
+  return false;
+}
+
 std::vector<NetworkAccessPoint> CNetworkInterfaceWin32::GetAccessPoints(void)
 {
    std::vector<NetworkAccessPoint> result;
diff --git a/xbmc/network/windows/NetworkWin32.h b/xbmc/network/windows/NetworkWin32.h
index 125ab58..975bba5 100644
--- a/xbmc/network/windows/NetworkWin32.h
+++ b/xbmc/network/windows/NetworkWin32.h
@@ -45,6 +45,8 @@ class CNetworkInterfaceWin32 : public CNetworkInterface
    virtual CStdString GetMacAddress(void);
    virtual void GetMacAddressRaw(char rawMac[6]);
 
+   virtual bool GetHostMacAddress(unsigned long host, CStdString& mac);
+
    virtual CStdString GetCurrentIPAddress();
    virtual CStdString GetCurrentNetmask();
    virtual CStdString GetCurrentDefaultGateway(void);
@@ -72,6 +74,9 @@ class CNetworkWin32 : public CNetwork
    // Return the list of interfaces
    virtual std::vector<CNetworkInterface*>& GetInterfaceList(void);
 
+   // Ping remote host
+   virtual bool PingHost(unsigned long host, unsigned int timeout_ms = 2000);
+
    // Get/set the nameserver(s)
    virtual std::vector<CStdString> GetNameServers(void);
    virtual void SetNameServers(std::vector<CStdString> nameServers);
diff --git a/xbmc/settings/GUISettings.cpp b/xbmc/settings/GUISettings.cpp
index 76ec0cc..6624585 100644
--- a/xbmc/settings/GUISettings.cpp
+++ b/xbmc/settings/GUISettings.cpp
@@ -612,6 +612,7 @@ void CGUISettings::Initialize()
 #endif
     AddInt(pwm, "powermanagement.shutdownstate", 13008, POWERSTATE_QUIT, shutdown, SPIN_CONTROL_TEXT);
   }
+  AddBool(pwm, "powermanagement.wakeonaccess", 13026, false);
 
   CSettingsCategory* dbg = AddCategory(SETTINGS_SYSTEM, "debug", 14092);
   AddBool(dbg, "debug.showloginfo", 20191, false);
diff --git a/xbmc/settings/GUIWindowSettingsCategory.cpp b/xbmc/settings/GUIWindowSettingsCategory.cpp
index 4ac2663..f468c9f 100644
--- a/xbmc/settings/GUIWindowSettingsCategory.cpp
+++ b/xbmc/settings/GUIWindowSettingsCategory.cpp
@@ -82,6 +82,7 @@
 #include "filesystem/SpecialProtocol.h"
 
 #include "network/Zeroconf.h"
+#include "network/WakeOnAccess.h"
 #include "peripherals/Peripherals.h"
 #include "peripherals/dialogs/GUIDialogPeripheralManager.h"
 #include "peripherals/devices/PeripheralImon.h"
@@ -2009,6 +2010,12 @@ void CGUIWindowSettingsCategory::OnSettingChanged(BaseSettingControlPtr pSetting
       }
     }
   }
+  else if (strSetting.Equals("powermanagement.wakeonaccess"))
+  {
+    CWakeOnAccess& woa = CWakeOnAccess::Get();
+    woa.SetEnabled (g_guiSettings.GetBool("powermanagement.wakeonaccess"));
+    woa.QueueMACDiscoveryForAllRemotes();
+  }
 
   UpdateSettings();
 }
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index 8a430ad..408e31a 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -51,6 +51,7 @@
 #include "cores/playercorefactory/PlayerCoreFactory.h"
 #include "utils/FileUtils.h"
 #include "utils/URIUtils.h"
+#include "network/WakeOnAccess.h"
 #include "input/MouseStat.h"
 #include "filesystem/File.h"
 #include "filesystem/DirectoryCache.h"
@@ -179,6 +180,7 @@ bool CSettings::Load()
   LoadSources();
   LoadRSSFeeds();
   LoadUserFolderLayout();
+  CWakeOnAccess::Get().LoadFromXML();
 
   return true;
 }
@@ -1226,6 +1228,8 @@ bool CSettings::UpdateShare(const CStdString &type, const CStdString oldName, co
   if (!pShare)
     return false;
 
+  CWakeOnAccess::Get().QueueMACDiscoveryForShare(*pShare);
+
   // Update our XML file as well
   return SaveSources();
 }
@@ -1317,6 +1321,8 @@ bool CSettings::AddShare(const CStdString &type, const CMediaSource &share)
   }
   pShares->push_back(shareToAdd);
 
+  CWakeOnAccess::Get().QueueMACDiscoveryForShare(shareToAdd);
+
   if (!share.m_ignore)
   {
     return SaveSources();
-- 
1.7.10


From 4dbdee502e504c0555547df7e2664a4a6a8c6242 Mon Sep 17 00:00:00 2001
From: "t4.ravenbird" <t4.ravenbird@gmail.com>
Date: Wed, 30 Jan 2013 12:50:24 +0100
Subject: [PATCH 2/2] [osx/ios/atv2] sync projects and mac discovery - by
 memphiz

---
 XBMC-ATV2.xcodeproj/project.pbxproj |   18 +++------
 XBMC-IOS.xcodeproj/project.pbxproj  |   18 +++------
 XBMC.xcodeproj/project.pbxproj      |   18 +++------
 xbmc/network/linux/NetworkLinux.cpp |   59 ++++++++++++++++++++++++++++-
 xbmc/network/osx/ioshacks.h         |   70 +++++++++++++++++++++++++++++++++++
 5 files changed, 146 insertions(+), 37 deletions(-)
 create mode 100644 xbmc/network/osx/ioshacks.h

diff --git a/XBMC-ATV2.xcodeproj/project.pbxproj b/XBMC-ATV2.xcodeproj/project.pbxproj
index 426c628..416f93f 100644
--- a/XBMC-ATV2.xcodeproj/project.pbxproj
+++ b/XBMC-ATV2.xcodeproj/project.pbxproj
@@ -100,8 +100,6 @@
 		C8B92B2215735EBF00284190 /* TextSearch.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C8B92B1F15735EBF00284190 /* TextSearch.cpp */; };
 		C8EC5D51136954E400CCC10D /* XBMC_keytable.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C8EC5D4F136954E400CCC10D /* XBMC_keytable.cpp */; };
 		DF004948162DB12200A971AD /* PVROperations.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF004946162DB12200A971AD /* PVROperations.cpp */; };
-		DF07255216873553008DCAAD /* karaokevideobackground.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF07255016873553008DCAAD /* karaokevideobackground.cpp */; };
-		DF07255516873565008DCAAD /* FFmpegVideoDecoder.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF07255316873565008DCAAD /* FFmpegVideoDecoder.cpp */; };
 		DF08E84515829BA600058C77 /* Exception.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF08E84315829BA600058C77 /* Exception.cpp */; };
 		DF0DF16D13A3AF82008ED511 /* NFSDirectory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF0DF16A13A3AF82008ED511 /* NFSDirectory.cpp */; };
 		DF23461015FA671900A934F6 /* UPnP.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF23460715FA671900A934F6 /* UPnP.cpp */; };
@@ -166,6 +164,7 @@
 		DFA0F9551618E1CD00611CBB /* DVDOverlayCodec.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFA0F9541618E1CD00611CBB /* DVDOverlayCodec.cpp */; };
 		DFA6BE8713FED2A10048CC11 /* AirPlayServer.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFA6BE8513FED2A10048CC11 /* AirPlayServer.cpp */; };
 		DFA6BE8A13FED2B40048CC11 /* HttpParser.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFA6BE8813FED2B40048CC11 /* HttpParser.cpp */; };
+		DFA815A216713BC400E4E597 /* WakeOnAccess.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFA815A016713BC400E4E597 /* WakeOnAccess.cpp */; };
 		DFAB04C113F8385F00B70BFB /* InertialScrollingHandler.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFAB04BF13F8385F00B70BFB /* InertialScrollingHandler.cpp */; };
 		DFAB4C0F15FCCB4300E1BAF6 /* TagLibVFSStream.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFAB4C0B15FCCB4300E1BAF6 /* TagLibVFSStream.cpp */; };
 		DFAB4C1015FCCB4300E1BAF6 /* TagLoaderTagLib.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFAB4C0D15FCCB4300E1BAF6 /* TagLoaderTagLib.cpp */; };
@@ -1226,10 +1225,6 @@
 		C8EC5D50136954E400CCC10D /* XBMC_keytable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XBMC_keytable.h; sourceTree = "<group>"; };
 		DF004946162DB12200A971AD /* PVROperations.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PVROperations.cpp; sourceTree = "<group>"; };
 		DF004947162DB12200A971AD /* PVROperations.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PVROperations.h; sourceTree = "<group>"; };
-		DF07255016873553008DCAAD /* karaokevideobackground.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = karaokevideobackground.cpp; sourceTree = "<group>"; };
-		DF07255116873553008DCAAD /* karaokevideobackground.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = karaokevideobackground.h; sourceTree = "<group>"; };
-		DF07255316873565008DCAAD /* FFmpegVideoDecoder.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FFmpegVideoDecoder.cpp; sourceTree = "<group>"; };
-		DF07255416873565008DCAAD /* FFmpegVideoDecoder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FFmpegVideoDecoder.h; sourceTree = "<group>"; };
 		DF08E84315829BA600058C77 /* Exception.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Exception.cpp; sourceTree = "<group>"; };
 		DF08E84415829BA600058C77 /* Exception.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Exception.h; sourceTree = "<group>"; };
 		DF0DF16A13A3AF82008ED511 /* NFSDirectory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = NFSDirectory.cpp; sourceTree = "<group>"; };
@@ -1405,6 +1400,8 @@
 		DFA6BE8613FED2A10048CC11 /* AirPlayServer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AirPlayServer.h; sourceTree = "<group>"; };
 		DFA6BE8813FED2B40048CC11 /* HttpParser.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = HttpParser.cpp; sourceTree = "<group>"; };
 		DFA6BE8913FED2B40048CC11 /* HttpParser.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = HttpParser.h; sourceTree = "<group>"; };
+		DFA815A016713BC400E4E597 /* WakeOnAccess.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WakeOnAccess.cpp; sourceTree = "<group>"; };
+		DFA815A116713BC400E4E597 /* WakeOnAccess.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WakeOnAccess.h; sourceTree = "<group>"; };
 		DFAB04BF13F8385F00B70BFB /* InertialScrollingHandler.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InertialScrollingHandler.cpp; sourceTree = "<group>"; };
 		DFAB04C013F8385F00B70BFB /* InertialScrollingHandler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InertialScrollingHandler.h; sourceTree = "<group>"; };
 		DFAB4C0B15FCCB4300E1BAF6 /* TagLibVFSStream.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = TagLibVFSStream.cpp; sourceTree = "<group>"; };
@@ -5363,8 +5360,6 @@
 				F56C75EE131EC153000AD0F6 /* karaokelyricstextlrc.h */,
 				F56C75EF131EC153000AD0F6 /* karaokelyricstextustar.cpp */,
 				F56C75F0131EC153000AD0F6 /* karaokelyricstextustar.h */,
-				DF07255016873553008DCAAD /* karaokevideobackground.cpp */,
-				DF07255116873553008DCAAD /* karaokevideobackground.h */,
 				F56C75F1131EC153000AD0F6 /* karaokewindowbackground.cpp */,
 				F56C75F2131EC153000AD0F6 /* karaokewindowbackground.h */,
 			);
@@ -5458,6 +5453,8 @@
 				F56C7668131EC153000AD0F6 /* TCPServer.h */,
 				F56C766B131EC153000AD0F6 /* UdpClient.cpp */,
 				F56C766C131EC153000AD0F6 /* UdpClient.h */,
+				DFA815A016713BC400E4E597 /* WakeOnAccess.cpp */,
+				DFA815A116713BC400E4E597 /* WakeOnAccess.h */,
 				F56C766D131EC153000AD0F6 /* WebServer.cpp */,
 				F56C766E131EC153000AD0F6 /* WebServer.h */,
 				F56C766F131EC153000AD0F6 /* Zeroconf.cpp */,
@@ -5873,8 +5870,6 @@
 				F56C778F131EC154000AD0F6 /* windows */,
 				F56C779A131EC154000AD0F6 /* Bookmark.cpp */,
 				F56C779B131EC154000AD0F6 /* Bookmark.h */,
-				DF07255316873565008DCAAD /* FFmpegVideoDecoder.cpp */,
-				DF07255416873565008DCAAD /* FFmpegVideoDecoder.h */,
 				F56C779C131EC154000AD0F6 /* GUIViewStateVideo.cpp */,
 				F56C779D131EC154000AD0F6 /* GUIViewStateVideo.h */,
 				F56C779E131EC154000AD0F6 /* Teletext.cpp */,
@@ -7665,8 +7660,7 @@
 				F5EDC4A91651A75700B852D8 /* GroupUtils.cpp in Sources */,
 				7C7CEB4B165629BF0059C9EB /* AELimiter.cpp in Sources */,
 				DFB02E0816629E1900F37752 /* PyContext.cpp in Sources */,
-				DF07255216873553008DCAAD /* karaokevideobackground.cpp in Sources */,
-				DF07255516873565008DCAAD /* FFmpegVideoDecoder.cpp in Sources */,
+				DFA815A216713BC400E4E597 /* WakeOnAccess.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
diff --git a/XBMC-IOS.xcodeproj/project.pbxproj b/XBMC-IOS.xcodeproj/project.pbxproj
index 8422f21..a1606c5 100644
--- a/XBMC-IOS.xcodeproj/project.pbxproj
+++ b/XBMC-IOS.xcodeproj/project.pbxproj
@@ -102,8 +102,6 @@
 		C8EC5D26136953E100CCC10D /* XBMC_keytable.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C8EC5D24136953E100CCC10D /* XBMC_keytable.cpp */; };
 		DF00493A162DB10400A971AD /* PVROperations.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF004938162DB10400A971AD /* PVROperations.cpp */; };
 		DF02A888153382A60084754E /* IOSKeyboard.mm in Sources */ = {isa = PBXBuildFile; fileRef = DF02A887153382A60084754E /* IOSKeyboard.mm */; };
-		DF07254116873517008DCAAD /* karaokevideobackground.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF07253F16873517008DCAAD /* karaokevideobackground.cpp */; };
-		DF0725441687352C008DCAAD /* FFmpegVideoDecoder.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF0725421687352C008DCAAD /* FFmpegVideoDecoder.cpp */; };
 		DF0DF18013A3AF9F008ED511 /* NFSDirectory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF0DF17D13A3AF9F008ED511 /* NFSDirectory.cpp */; };
 		DF23462215FA675200A934F6 /* UPnP.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF23461915FA675200A934F6 /* UPnP.cpp */; };
 		DF23462315FA675200A934F6 /* UPnPInternal.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF23461B15FA675200A934F6 /* UPnPInternal.cpp */; };
@@ -167,6 +165,7 @@
 		DFA0F9291618E18A00611CBB /* DVDOverlayCodec.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFA0F9281618E18A00611CBB /* DVDOverlayCodec.cpp */; };
 		DFA6BE4313FECA010048CC11 /* AirPlayServer.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFA6BE4113FECA010048CC11 /* AirPlayServer.cpp */; };
 		DFA6BE7713FED09C0048CC11 /* HttpParser.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFA6BE7513FED09C0048CC11 /* HttpParser.cpp */; };
+		DFA8158E16713BA100E4E597 /* WakeOnAccess.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFA8158C16713BA100E4E597 /* WakeOnAccess.cpp */; };
 		DFAB04B013F8383300B70BFB /* InertialScrollingHandler.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFAB04AE13F8383300B70BFB /* InertialScrollingHandler.cpp */; };
 		DFAB4BE615FCCA5000E1BAF6 /* TagLibVFSStream.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFAB4BE215FCCA5000E1BAF6 /* TagLibVFSStream.cpp */; };
 		DFAB4BE715FCCA5000E1BAF6 /* TagLoaderTagLib.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFAB4BE415FCCA5000E1BAF6 /* TagLoaderTagLib.cpp */; };
@@ -1232,10 +1231,6 @@
 		DF02A86D153381990084754E /* GUIKeyboard.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GUIKeyboard.h; sourceTree = "<group>"; };
 		DF02A881153382560084754E /* IOSKeyboard.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = IOSKeyboard.h; sourceTree = "<group>"; };
 		DF02A887153382A60084754E /* IOSKeyboard.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; path = IOSKeyboard.mm; sourceTree = "<group>"; };
-		DF07253F16873517008DCAAD /* karaokevideobackground.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = karaokevideobackground.cpp; sourceTree = "<group>"; };
-		DF07254016873517008DCAAD /* karaokevideobackground.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = karaokevideobackground.h; sourceTree = "<group>"; };
-		DF0725421687352C008DCAAD /* FFmpegVideoDecoder.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FFmpegVideoDecoder.cpp; sourceTree = "<group>"; };
-		DF0725431687352C008DCAAD /* FFmpegVideoDecoder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FFmpegVideoDecoder.h; sourceTree = "<group>"; };
 		DF0DF17D13A3AF9F008ED511 /* NFSDirectory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = NFSDirectory.cpp; sourceTree = "<group>"; };
 		DF0DF17E13A3AF9F008ED511 /* NFSDirectory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NFSDirectory.h; sourceTree = "<group>"; };
 		DF1ACFF615FCE57C00E10810 /* AddonModuleXbmc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = AddonModuleXbmc.cpp; sourceTree = "<group>"; };
@@ -1408,6 +1403,8 @@
 		DFA6BE4213FECA010048CC11 /* AirPlayServer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AirPlayServer.h; sourceTree = "<group>"; };
 		DFA6BE7513FED09C0048CC11 /* HttpParser.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = HttpParser.cpp; sourceTree = "<group>"; };
 		DFA6BE7613FED09C0048CC11 /* HttpParser.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = HttpParser.h; sourceTree = "<group>"; };
+		DFA8158C16713BA100E4E597 /* WakeOnAccess.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WakeOnAccess.cpp; sourceTree = "<group>"; };
+		DFA8158D16713BA100E4E597 /* WakeOnAccess.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WakeOnAccess.h; sourceTree = "<group>"; };
 		DFAB04AE13F8383300B70BFB /* InertialScrollingHandler.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InertialScrollingHandler.cpp; sourceTree = "<group>"; };
 		DFAB04AF13F8383300B70BFB /* InertialScrollingHandler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InertialScrollingHandler.h; sourceTree = "<group>"; };
 		DFAB4BE215FCCA5000E1BAF6 /* TagLibVFSStream.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = TagLibVFSStream.cpp; sourceTree = "<group>"; };
@@ -5720,8 +5717,6 @@
 				F56C85D1131F42EA000AD0F6 /* karaokelyricstextlrc.h */,
 				F56C85D2131F42EA000AD0F6 /* karaokelyricstextustar.cpp */,
 				F56C85D3131F42EA000AD0F6 /* karaokelyricstextustar.h */,
-				DF07253F16873517008DCAAD /* karaokevideobackground.cpp */,
-				DF07254016873517008DCAAD /* karaokevideobackground.h */,
 				F56C85D4131F42EA000AD0F6 /* karaokewindowbackground.cpp */,
 				F56C85D5131F42EA000AD0F6 /* karaokewindowbackground.h */,
 			);
@@ -5815,6 +5810,8 @@
 				F56C864B131F42EB000AD0F6 /* TCPServer.h */,
 				F56C864E131F42EB000AD0F6 /* UdpClient.cpp */,
 				F56C864F131F42EB000AD0F6 /* UdpClient.h */,
+				DFA8158C16713BA100E4E597 /* WakeOnAccess.cpp */,
+				DFA8158D16713BA100E4E597 /* WakeOnAccess.h */,
 				F56C8650131F42EB000AD0F6 /* WebServer.cpp */,
 				F56C8651131F42EB000AD0F6 /* WebServer.h */,
 				F56C8652131F42EB000AD0F6 /* Zeroconf.cpp */,
@@ -6239,8 +6236,6 @@
 				F56C877E131F42EC000AD0F6 /* windows */,
 				F56C8789131F42EC000AD0F6 /* Bookmark.cpp */,
 				F56C878A131F42EC000AD0F6 /* Bookmark.h */,
-				DF0725421687352C008DCAAD /* FFmpegVideoDecoder.cpp */,
-				DF0725431687352C008DCAAD /* FFmpegVideoDecoder.h */,
 				F56C878B131F42EC000AD0F6 /* GUIViewStateVideo.cpp */,
 				F56C878C131F42EC000AD0F6 /* GUIViewStateVideo.h */,
 				F56C878D131F42EC000AD0F6 /* Teletext.cpp */,
@@ -7690,8 +7685,7 @@
 				F5EDC4A61651A74300B852D8 /* GroupUtils.cpp in Sources */,
 				7C7CEB5F165629F90059C9EB /* AELimiter.cpp in Sources */,
 				DFB02DFB16629DF200F37752 /* PyContext.cpp in Sources */,
-				DF07254116873517008DCAAD /* karaokevideobackground.cpp in Sources */,
-				DF0725441687352C008DCAAD /* FFmpegVideoDecoder.cpp in Sources */,
+				DFA8158E16713BA100E4E597 /* WakeOnAccess.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
diff --git a/XBMC.xcodeproj/project.pbxproj b/XBMC.xcodeproj/project.pbxproj
index bf4a009..b8e362d 100644
--- a/XBMC.xcodeproj/project.pbxproj
+++ b/XBMC.xcodeproj/project.pbxproj
@@ -375,8 +375,6 @@
 		C8D0B2AF1265A9A800F0C0AC /* SystemGlobals.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C8D0B2AE1265A9A800F0C0AC /* SystemGlobals.cpp */; };
 		C8EC5D0E1369519D00CCC10D /* XBMC_keytable.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C8EC5D0C1369519D00CCC10D /* XBMC_keytable.cpp */; };
 		DF00492D162DAEA200A971AD /* PVROperations.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF00492B162DAEA200A971AD /* PVROperations.cpp */; };
-		DF07252E168734D7008DCAAD /* karaokevideobackground.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF07252C168734D7008DCAAD /* karaokevideobackground.cpp */; };
-		DF072534168734ED008DCAAD /* FFmpegVideoDecoder.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF072532168734ED008DCAAD /* FFmpegVideoDecoder.cpp */; };
 		DF0DF15C13A3ADA7008ED511 /* NFSDirectory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF0DF15913A3ADA7008ED511 /* NFSDirectory.cpp */; };
 		DF2345E115FA639500A934F6 /* UPnP.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF2345D915FA639500A934F6 /* UPnP.cpp */; settings = {COMPILER_FLAGS = "-I$SRCROOT/lib/libUPnP/Platinum/Source/Core -I$SRCROOT/lib/libUPnP/Platinum/Source/Platinum -I$SRCROOT/lib/libUPnP/Platinum/Source/Devices/MediaConnect -I$SRCROOT/lib/libUPnP/Platinum/Source/Devices/MediaRenderer -I$SRCROOT/lib/libUPnP/Platinum/Source/Devices/MediaServer -I$SRCROOT/lib/libUPnP/Platinum/Source/Extras -I$SRCROOT/lib/libUPnP/Neptune/Source/System/Posix -I$SRCROOT/lib/libUPnP/Neptune/Source/Core"; }; };
 		DF2345E215FA639500A934F6 /* UPnPInternal.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF2345DB15FA639500A934F6 /* UPnPInternal.cpp */; settings = {COMPILER_FLAGS = "-I$SRCROOT/lib/libUPnP/Platinum/Source/Core -I$SRCROOT/lib/libUPnP/Platinum/Source/Platinum -I$SRCROOT/lib/libUPnP/Platinum/Source/Devices/MediaConnect -I$SRCROOT/lib/libUPnP/Platinum/Source/Devices/MediaRenderer -I$SRCROOT/lib/libUPnP/Platinum/Source/Devices/MediaServer -I$SRCROOT/lib/libUPnP/Platinum/Source/Extras -I$SRCROOT/lib/libUPnP/Neptune/Source/System/Posix -I$SRCROOT/lib/libUPnP/Neptune/Source/Core"; }; };
@@ -439,6 +437,7 @@
 		DF93D7F61444B568007C6459 /* HDHomeRunDirectory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF93D7F51444B568007C6459 /* HDHomeRunDirectory.cpp */; };
 		DF98D98C1434F47D00A6EBE1 /* SkinVariable.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF98D98A1434F47D00A6EBE1 /* SkinVariable.cpp */; };
 		DF9A71EE1639C8F6005ECB2E /* HTTPFile.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF9A71EC1639C8F6005ECB2E /* HTTPFile.cpp */; };
+		DFA8157E16713B1200E4E597 /* WakeOnAccess.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFA8157C16713B1200E4E597 /* WakeOnAccess.cpp */; };
 		DFAB049813F8376700B70BFB /* InertialScrollingHandler.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFAB049613F8376700B70BFB /* InertialScrollingHandler.cpp */; };
 		DFB02DEA16629DBA00F37752 /* PyContext.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFB02DE816629DBA00F37752 /* PyContext.cpp */; };
 		DFB0F472161B747500D744F4 /* AddonsOperations.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFB0F470161B747500D744F4 /* AddonsOperations.cpp */; };
@@ -1827,10 +1826,6 @@
 		C8EC5D0D1369519D00CCC10D /* XBMC_keytable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XBMC_keytable.h; sourceTree = "<group>"; };
 		DF00492B162DAEA200A971AD /* PVROperations.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PVROperations.cpp; sourceTree = "<group>"; };
 		DF00492C162DAEA200A971AD /* PVROperations.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PVROperations.h; sourceTree = "<group>"; };
-		DF07252C168734D7008DCAAD /* karaokevideobackground.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = karaokevideobackground.cpp; sourceTree = "<group>"; };
-		DF07252D168734D7008DCAAD /* karaokevideobackground.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = karaokevideobackground.h; sourceTree = "<group>"; };
-		DF072532168734ED008DCAAD /* FFmpegVideoDecoder.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FFmpegVideoDecoder.cpp; sourceTree = "<group>"; };
-		DF072533168734ED008DCAAD /* FFmpegVideoDecoder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FFmpegVideoDecoder.h; sourceTree = "<group>"; };
 		DF0DF15913A3ADA7008ED511 /* NFSDirectory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = NFSDirectory.cpp; sourceTree = "<group>"; };
 		DF0DF15A13A3ADA7008ED511 /* NFSDirectory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NFSDirectory.h; sourceTree = "<group>"; };
 		DF1ACFD115FCE50700E10810 /* AddonModuleXbmc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = AddonModuleXbmc.cpp; sourceTree = "<group>"; };
@@ -2001,6 +1996,8 @@
 		DF98D98B1434F47D00A6EBE1 /* SkinVariable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SkinVariable.h; sourceTree = "<group>"; };
 		DF9A71EC1639C8F6005ECB2E /* HTTPFile.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = HTTPFile.cpp; sourceTree = "<group>"; };
 		DF9A71ED1639C8F6005ECB2E /* HTTPFile.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = HTTPFile.h; sourceTree = "<group>"; };
+		DFA8157C16713B1200E4E597 /* WakeOnAccess.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WakeOnAccess.cpp; sourceTree = "<group>"; };
+		DFA8157D16713B1200E4E597 /* WakeOnAccess.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WakeOnAccess.h; sourceTree = "<group>"; };
 		DFAB049613F8376700B70BFB /* InertialScrollingHandler.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InertialScrollingHandler.cpp; sourceTree = "<group>"; };
 		DFAB049713F8376700B70BFB /* InertialScrollingHandler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InertialScrollingHandler.h; sourceTree = "<group>"; };
 		DFB02DE816629DBA00F37752 /* PyContext.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PyContext.cpp; path = python/PyContext.cpp; sourceTree = "<group>"; };
@@ -3869,8 +3866,6 @@
 				F54C51E00F1E787700D46E3C /* karaokelyricstextlrc.h */,
 				7CDAEA7B1001CD6E0040B25F /* karaokelyricstextustar.cpp */,
 				7CDAEA7C1001CD6E0040B25F /* karaokelyricstextustar.h */,
-				DF07252C168734D7008DCAAD /* karaokevideobackground.cpp */,
-				DF07252D168734D7008DCAAD /* karaokevideobackground.h */,
 				F56A084A0F4A18FB003F9F87 /* karaokewindowbackground.cpp */,
 				F56A08490F4A18FB003F9F87 /* karaokewindowbackground.h */,
 			);
@@ -3993,6 +3988,8 @@
 				432D7CF512D870D600CE4C49 /* TCPServer.h */,
 				E38E1E8B0D25F9FD00618676 /* UdpClient.cpp */,
 				E38E1E8C0D25F9FD00618676 /* UdpClient.h */,
+				DFA8157C16713B1200E4E597 /* WakeOnAccess.cpp */,
+				DFA8157D16713B1200E4E597 /* WakeOnAccess.h */,
 				F5A7A859112908F00059D6AA /* WebServer.cpp */,
 				F5A7A85A112908F00059D6AA /* WebServer.h */,
 				E46F7C280F77217400C25D29 /* Zeroconf.cpp */,
@@ -4152,8 +4149,6 @@
 				43FAC88812D6364800F67914 /* windows */,
 				7C62F24010505BC7002AD2C1 /* Bookmark.cpp */,
 				7C62F24110505BC7002AD2C1 /* Bookmark.h */,
-				DF072532168734ED008DCAAD /* FFmpegVideoDecoder.cpp */,
-				DF072533168734ED008DCAAD /* FFmpegVideoDecoder.h */,
 				E38E17FF0D25F9FA00618676 /* GUIViewStateVideo.cpp */,
 				E38E18000D25F9FA00618676 /* GUIViewStateVideo.h */,
 				F5E55B6E10741340006E788A /* Teletext.cpp */,
@@ -7722,8 +7717,7 @@
 				F5EDC48C1651A6F900B852D8 /* GroupUtils.cpp in Sources */,
 				7C7CEAF1165629530059C9EB /* AELimiter.cpp in Sources */,
 				DFB02DEA16629DBA00F37752 /* PyContext.cpp in Sources */,
-				DF07252E168734D7008DCAAD /* karaokevideobackground.cpp in Sources */,
-				DF072534168734ED008DCAAD /* FFmpegVideoDecoder.cpp in Sources */,
+				DFA8157E16713B1200E4E597 /* WakeOnAccess.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
diff --git a/xbmc/network/linux/NetworkLinux.cpp b/xbmc/network/linux/NetworkLinux.cpp
index 411f60c..aab8d1d 100644
--- a/xbmc/network/linux/NetworkLinux.cpp
+++ b/xbmc/network/linux/NetworkLinux.cpp
@@ -37,6 +37,13 @@
   #include <sys/sockio.h>
   #include <net/if.h>
   #include <net/if_dl.h>
+#if defined(TARGET_DARWIN_OSX)
+  #include <net/if_types.h>
+  #include <net/route.h>
+  #include <netinet/if_ether.h>
+#else //IOS
+  #include "network/osx/ioshacks.h"
+#endif
   #include <ifaddrs.h>
 #elif defined(TARGET_FREEBSD)
   #include <sys/sockio.h>
@@ -544,6 +551,56 @@ bool CNetworkLinux::PingHost(unsigned long remote_ip, unsigned int timeout_ms)
   return result == 0;
 }
 
+#if defined TARGET_DARWIN
+bool CNetworkInterfaceLinux::GetHostMacAddress(unsigned long host_ip, CStdString& mac)
+{
+  bool ret = false;
+  size_t needed;
+  char *buf, *next;
+  struct rt_msghdr *rtm;
+  struct sockaddr_inarp *sin;
+  struct sockaddr_dl *sdl;
+  int mib[6];
+  
+  mac = "";
+  
+  mib[0] = CTL_NET;
+  mib[1] = PF_ROUTE;
+  mib[2] = 0;
+  mib[3] = AF_INET;
+  mib[4] = NET_RT_FLAGS;
+  mib[5] = RTF_LLINFO;
+  
+  if (sysctl(mib, sizeof(mib) / sizeof(mib[0]), NULL, &needed, NULL, 0) == 0)
+  {   
+    if (buf = (char*)malloc(needed))
+    {      
+      if (sysctl(mib, sizeof(mib) / sizeof(mib[0]), buf, &needed, NULL, 0) == 0)
+      {        
+        for (next = buf; next < buf + needed; next += rtm->rtm_msglen) 
+        {
+          
+          rtm = (struct rt_msghdr *)next;
+          sin = (struct sockaddr_inarp *)(rtm + 1);
+          sdl = (struct sockaddr_dl *)(sin + 1);
+          
+          if (host_ip != sin->sin_addr.s_addr || sdl->sdl_alen < 6)
+            continue;
+          
+          u_char *cp = (u_char*)LLADDR(sdl);
+          
+          mac.Format("%02X:%02X:%02X:%02X:%02X:%02X",
+                     cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);
+          ret = true;
+          break;
+        }
+      }
+      free(buf);
+    }
+  }
+  return ret;
+}
+#else
 bool CNetworkInterfaceLinux::GetHostMacAddress(unsigned long host_ip, CStdString& mac)
 {
   struct arpreq areq;
@@ -576,6 +633,7 @@ bool CNetworkInterfaceLinux::GetHostMacAddress(unsigned long host_ip, CStdString
 
   return true;
 }
+#endif
 
 std::vector<NetworkAccessPoint> CNetworkInterfaceLinux::GetAccessPoints(void)
 {
@@ -984,4 +1042,3 @@ void CNetworkInterfaceLinux::WriteSettings(FILE* fw, NetworkAssignment assignmen
       fprintf(fw, "auto %s\n\n", GetName().c_str());
 }
 
-
diff --git a/xbmc/network/osx/ioshacks.h b/xbmc/network/osx/ioshacks.h
new file mode 100644
index 0000000..5cc687e
--- /dev/null
+++ b/xbmc/network/osx/ioshacks.h
@@ -0,0 +1,70 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+// needed for CNetworkInterfaceLinux::GetHostMacAddress and taken from osx sdk
+// net/if_types.h net/route.h netinet/if_ether.h
+
+/*
+ * These numbers are used by reliable protocols for determining
+ * retransmission behavior and are included in the routing structure.
+ */
+struct rt_metrics {
+	u_int32_t	rmx_locks;	/* Kernel must leave these values alone */
+	u_int32_t	rmx_mtu;	/* MTU for this path */
+	u_int32_t	rmx_hopcount;	/* max hops expected */
+	int32_t		rmx_expire;	/* lifetime for route, e.g. redirect */
+	u_int32_t	rmx_recvpipe;	/* inbound delay-bandwidth product */
+	u_int32_t	rmx_sendpipe;	/* outbound delay-bandwidth product */
+	u_int32_t	rmx_ssthresh;	/* outbound gateway buffer limit */
+	u_int32_t	rmx_rtt;	/* estimated round trip time */
+	u_int32_t	rmx_rttvar;	/* estimated rtt variance */
+	u_int32_t	rmx_pksent;	/* packets sent using this route */
+	u_int32_t	rmx_filler[4];	/* will be used for T/TCP later */
+};
+
+/*
+ * Structures for routing messages.
+ */
+struct rt_msghdr {
+	u_short	rtm_msglen;		/* to skip over non-understood messages */
+	u_char	rtm_version;		/* future binary compatibility */
+	u_char	rtm_type;		/* message type */
+	u_short	rtm_index;		/* index for associated ifp */
+	int	rtm_flags;		/* flags, incl. kern & message, e.g. DONE */
+	int	rtm_addrs;		/* bitmask identifying sockaddrs in msg */
+	pid_t	rtm_pid;		/* identify sender */
+	int	rtm_seq;		/* for sender to identify action */
+	int	rtm_errno;		/* why failed */
+	int	rtm_use;		/* from rtentry */
+	u_int32_t rtm_inits;		/* which metrics we are initializing */
+	struct rt_metrics rtm_rmx;	/* metrics themselves */
+};
+struct sockaddr_inarp {
+	u_char	sin_len;
+	u_char	sin_family;
+	u_short sin_port;
+	struct	in_addr sin_addr;
+	struct	in_addr sin_srcaddr;
+	u_short	sin_tos;
+	u_short	sin_other;
+#define SIN_PROXY 1
+};
+#define RTF_LLINFO	0x400		/* generated by link layer (e.g. ARP) */
+// --- END
-- 
1.7.10

